// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteEntry = `-- name: DeleteEntry :exec
DELETE FROM entry
WHERE language = $1 AND entry = $2
`

type DeleteEntryParams struct {
	Language string
	Entry    string
}

func (q *Queries) DeleteEntry(ctx context.Context, arg DeleteEntryParams) error {
	_, err := q.db.Exec(ctx, deleteEntry, arg.Language, arg.Entry)
	return err
}

const getEntry = `-- name: GetEntry :one
SELECT language, entry, status, description, common_mistakes, level, data,
       updated, updated_by
FROM entry
WHERE language = $1 AND entry = $2
`

type GetEntryParams struct {
	Language string
	Entry    string
}

func (q *Queries) GetEntry(ctx context.Context, arg GetEntryParams) (Entry, error) {
	row := q.db.QueryRow(ctx, getEntry, arg.Language, arg.Entry)
	var i Entry
	err := row.Scan(
		&i.Language,
		&i.Entry,
		&i.Status,
		&i.Description,
		&i.CommonMistakes,
		&i.Level,
		&i.Data,
		&i.Updated,
		&i.UpdatedBy,
	)
	return i, err
}

const listDictionaries = `-- name: ListDictionaries :many
SELECT language, COUNT(*) AS entries
FROM entry
GROUP BY language
`

type ListDictionariesRow struct {
	Language string
	Entries  int64
}

func (q *Queries) ListDictionaries(ctx context.Context) ([]ListDictionariesRow, error) {
	rows, err := q.db.Query(ctx, listDictionaries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDictionariesRow
	for rows.Next() {
		var i ListDictionariesRow
		if err := rows.Scan(&i.Language, &i.Entries); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEntries = `-- name: ListEntries :many
SELECT language, entry, status, description, common_mistakes, level, data,
       updated, updated_by
FROM entry
WHERE
        ($1::text IS NULL OR language = $1)
        AND ($2::text IS NULL OR entry LIKE $2)
        AND ($3::text IS NULL OR status = $3)
LIMIT $5::bigint OFFSET $4::bigint
`

type ListEntriesParams struct {
	Language pgtype.Text
	Pattern  pgtype.Text
	Status   pgtype.Text
	Offset   int64
	Limit    int64
}

func (q *Queries) ListEntries(ctx context.Context, arg ListEntriesParams) ([]Entry, error) {
	rows, err := q.db.Query(ctx, listEntries,
		arg.Language,
		arg.Pattern,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Entry
	for rows.Next() {
		var i Entry
		if err := rows.Scan(
			&i.Language,
			&i.Entry,
			&i.Status,
			&i.Description,
			&i.CommonMistakes,
			&i.Level,
			&i.Data,
			&i.Updated,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const notify = `-- name: Notify :exec
SELECT pg_notify($1::text, $2::text)
`

type NotifyParams struct {
	Channel string
	Message string
}

func (q *Queries) Notify(ctx context.Context, arg NotifyParams) error {
	_, err := q.db.Exec(ctx, notify, arg.Channel, arg.Message)
	return err
}

const setEntry = `-- name: SetEntry :exec
INSERT INTO entry(
       language, entry, status, description, common_mistakes, level, data,
       updated, updated_by
) VALUES (
       $1, $2, $3, $4, $5, $6, $7,
       $8, $9
) ON CONFLICT(language, entry) DO
  UPDATE SET
       status = excluded.status,
       description = excluded.description,
       common_mistakes = excluded.common_mistakes,
       level = excluded.level,
       data = excluded.data,
       updated = excluded.updated,
       updated_by = excluded.updated_by
`

type SetEntryParams struct {
	Language       string
	Entry          string
	Status         string
	Description    string
	CommonMistakes []string
	Level          EntryLevel
	Data           *EntryData
	Updated        pgtype.Timestamptz
	UpdatedBy      string
}

func (q *Queries) SetEntry(ctx context.Context, arg SetEntryParams) error {
	_, err := q.db.Exec(ctx, setEntry,
		arg.Language,
		arg.Entry,
		arg.Status,
		arg.Description,
		arg.CommonMistakes,
		arg.Level,
		arg.Data,
		arg.Updated,
		arg.UpdatedBy,
	)
	return err
}
